{******************************************************************************}
{                       CnPack For Delphi/C++Builder                           }
{                     中国人自己的开放源码第三方开发包                         }
{                   (C)Copyright 2001-2025 CnPack 开发组                       }
{                   ------------------------------------                       }
{                                                                              }
{            本开发包是开源的自由软件，您可以遵照 CnPack 的发布协议来修        }
{        改和重新发布这一程序。                                                }
{                                                                              }
{            发布这一开发包的目的是希望它有用，但没有任何担保。甚至没有        }
{        适合特定目的而隐含的担保。更详细的情况请参阅 CnPack 发布协议。        }
{                                                                              }
{            您应该已经和开发包一起收到一份 CnPack 发布协议的副本。如果        }
{        还没有，可访问我们的网站：                                            }
{                                                                              }
{            网站地址：https://www.cnpack.org                                  }
{            电子邮件：master@cnpack.org                                       }
{                                                                              }
{******************************************************************************}

unit CnEditorExtSelect;
{* |<PRE>
================================================================================
* 软件名称：CnPack IDE 专家包
* 单元名称：层级渐进选择实现单元
* 单元作者：CnPack 开发组 (master@cnpack.org)
* 备    注：
* 开发平台：PWin7 SP2 + Delphi 5.01
* 兼容测试：PWin7 + Delphi 5/6/7 + C++Builder 5/6
* 本 地 化：该窗体中的字符串均符合本地化处理方式
* 修改记录：2025.04.29 V1.1
*               完善部分 Pascal 代码的功能
*           2021.10.06 V1.0
*               创建单元，实现功能
================================================================================
|</PRE>}

interface

{$I CnWizards.inc}

uses
  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,
  StdCtrls, ExtCtrls, IniFiles, Menus, ToolsAPI,
  CnWizUtils, CnConsts, CnCommon, CnWizManager, CnWizEditFiler,
  CnCodingToolsetWizard, CnWizConsts, CnSelectionCodeTool, CnWizIdeUtils,
  CnSourceHighlight, CnPasCodeParser, CnEditControlWrapper, mPasLex,
  CnCppCodeParser, mwBCBTokenList;

type
  TCnEditorExtendingSelect = class(TCnBaseCodingToolset)
  private
    FEditPos: TOTAEditPos;
    FSelectStep: Integer;
    FTimer: TTimer;
    FNeedReparse: Boolean;
    FSelecting: Boolean;
    FStartPos, FEndPos: TOTACharPos;
    procedure FixPair(APair: TCnBlockLinePair);
    procedure CheckModifiedAndReparse;
    procedure EditorChanged(Editor: TCnEditorObject; ChangeType:
      TCnEditorChangeTypes);
    procedure OnSelectTimer(Sender: TObject);
  protected
    function GetDefShortCut: TShortCut; override;
  public
    constructor Create(AOwner: TCnCodingToolsetWizard); override;
    destructor Destroy; override;

    function GetCaption: string; override;
    function GetHint: string; override;
    procedure GetToolsetInfo(var Name, Author, Email: string); override;
    procedure Execute; override;
  end;

implementation

uses
  CnIDEStrings {$IFDEF DEBUG}, CnDebug {$ENDIF};

{ TCnEditorExtendingSelect }

procedure TCnEditorExtendingSelect.FixPair(APair: TCnBlockLinePair);
begin
  if APair.MiddleCount > 0 then
  begin
    if APair.EndToken.TokenID in [tkElse, tkExcept, tkFinally, tkCase] then
    begin
      APair.EndToken := APair.MiddleToken[APair.MiddleCount - 1];
      APair.DeleteMidToken(APair.MiddleCount - 1);
    end;
  end;
end;

procedure TCnEditorExtendingSelect.CheckModifiedAndReparse;
const
  NO_LAYER = -2;
var
  EditView: IOTAEditView;
  EditControl: TControl;
  CurrIndex, I, J, InnerIdx, PairLevel, Step: Integer;
  PasParser: TCnGeneralPasStructParser;
  CppParser: TCnGeneralCppStructParser;
  Stream: TMemoryStream;
  CharPos: TOTACharPos;
  CurrentToken, T1, T2: TCnGeneralPasToken;
  CurrentTokenName: TCnIdeTokenString;
  CurIsPas, CurIsCpp, BeginEndFound, AreaFound, CursorInPair: Boolean;
  CurrentTokenIndex: Integer;
  BlockMatchInfo: TCnBlockMatchInfo;
  MaxInnerLayer, MinOutLayer: Integer;
  Pair, TmpPair, InnerPair: TCnBlockLinePair;
  LastS: string;

  // 判断一个 Pair 是否包括了光标位置，关键字也包括进去了，闭区间
  function EditPosInPairClose(AEditPos: TOTAEditPos; APairStart, APairEnd: TCnGeneralPasToken): Boolean;
  var
    AfterStart, BeforeEnd: Boolean;
  begin
    AfterStart := (AEditPos.Line > APairStart.EditLine) or
      ((AEditPos.Line = APairStart.EditLine) and (AEditPos.Col >= APairStart.EditCol));
    BeforeEnd := (AEditPos.Line < APairEnd.EditLine) or
      ((AEditPos.Line = APairEnd.EditLine) and (AEditPos.Col <= APairEnd.EditEndCol));

    Result := AfterStart and BeforeEnd;
{$IFDEF DEBUG}
//    CnDebugger.LogFmt('EditPosInPairClose Step %d. Is %d %d in Open %d %d to %d %d? %d',
//      [Step, AEditPos.Line, AEditPos.Col, APairStart.EditLine, APairStart.EditCol,
//      APairEnd.EditLine, APairEnd.EditEndCol, Ord(Result)]);
{$ENDIF}
  end;

  // 判断一个 Pair 是否包括了光标位置，不包括头尾关键字，开区间（注意头关键字后、尾关键字前，算包括）。
  function EditPosInPairOpen(AEditPos: TOTAEditPos; APairStart, APairEnd: TCnGeneralPasToken): Boolean;
  var
    AfterStart, BeforeEnd: Boolean;
  begin
    AfterStart := (AEditPos.Line > APairStart.EditLine) or
      ((AEditPos.Line = APairStart.EditLine) and (AEditPos.Col >= APairStart.EditEndCol));
    BeforeEnd := (AEditPos.Line < APairEnd.EditLine) or
      ((AEditPos.Line = APairEnd.EditLine) and (AEditPos.Col <= APairEnd.EditCol));

    Result := AfterStart and BeforeEnd;
{$IFDEF DEBUG}
//    CnDebugger.LogFmt('EditPosInPairOpen Step %d. Is %d %d in Open %d %d to %d %d? %d',
//      [Step, AEditPos.Line, AEditPos.Col, APairStart.EditLine, APairStart.EditEndCol,
//      APairEnd.EditLine, APairEnd.EditCol, Ord(Result)]);
{$ENDIF}
  end;

  procedure SetStartEndPos(StartToken, EndToken: TCnGeneralPasToken; Open: Boolean);
  begin
    if Open then
    begin
      FStartPos.Line := StartToken.EditLine;
      FStartPos.CharIndex := StartToken.EditEndCol;
      FEndPos.Line := EndToken.EditLine;
      FEndPos.CharIndex := EndToken.EditCol;
{$IFDEF DEBUG}
      CnDebugger.LogFmt('Success! Open at Step %d. %s ... %s', [Step, StartToken.Token, EndToken.Token]);
{$ENDIF}
    end
    else
    begin
      FStartPos.Line := StartToken.EditLine;
      FStartPos.CharIndex := StartToken.EditCol;
      FEndPos.Line := EndToken.EditLine;
      FEndPos.CharIndex := EndToken.EditEndCol;
{$IFDEF DEBUG}
      CnDebugger.LogFmt('Success! Close at Step %d at %s ... %s', [Step, StartToken.Token, EndToken.Token]);
{$ENDIF}
    end;
    AreaFound := True;
  end;

  // 拿到一个 Pair 后，步进 Step 以各种开闭区间搜，
  // 内部使用 Step 步进、FLevel 比较、AreaFound 输出是否找到等外部变量
  procedure SearchInAPair(APair: TCnBlockLinePair);
  var
    I: Integer;
  begin
{$IFDEF DEBUG}
//    CnDebugger.LogFmt('Search A Pair with MiddleCount %d. Step Start From %d to Meet Dest Step %d',
//      [APair.MiddleCount, Step, FSelectStep]);
{$ENDIF}
    if APair.MiddleCount = 0 then
    begin
      // 普通 Pair，找头尾开区间，Step + 1，判断
      if EditPosInPairOpen(FEditPos, APair.StartToken, APair.EndToken) then
      begin
        Inc(Step);
        if Step = FSelectStep then
        begin
          SetStartEndPos(APair.StartToken, APair.EndToken, True);
          Exit;
        end;
      end;

      // 普通 Pair，找头尾闭区间，Step + 1， 判断
      if EditPosInPairClose(FEditPos, APair.StartToken, APair.EndToken) then
      begin
        Inc(Step);
        if Step = FSelectStep then
        begin
          SetStartEndPos(APair.StartToken, APair.EndToken, False);
          Exit;
        end;
      end;
    end
    else
    begin
      // 多结构 Pair，找所在头尾的开、闭区间，Step + 1，判断
      for I := 0 to APair.MiddleCount - 1 do
      begin
        if I = 0 then
        begin
          // 第一个中间，开始和第一个中间的开区间判断
          if EditPosInPairOpen(FEditPos, APair.StartToken, APair.MiddleToken[I]) then
          begin
            Inc(Step);
            if Step = FSelectStep then
            begin
              SetStartEndPos(APair.StartToken, APair.MiddleToken[I], True);
              Exit;
            end;
          end;

          // 第一个中间，开始和第一个中间的闭区间判断
          if EditPosInPairClose(FEditPos, APair.StartToken, APair.MiddleToken[I]) then
          begin
            Inc(Step);
            if Step = FSelectStep then
            begin
              SetStartEndPos(APair.StartToken, APair.MiddleToken[I], False);
              Exit;
            end;
          end;
        end;

        if I = APair.MiddleCount - 1 then // 注意不能 else if
        begin
          // 最后一个中间，最后一个中间和结尾的开区间判断
          if EditPosInPairOpen(FEditPos, APair.MiddleToken[I], APair.EndToken) then
          begin
            Inc(Step);
            if Step = FSelectStep then
            begin
              SetStartEndPos(APair.MiddleToken[I], APair.EndToken, True);
              Exit;
            end;
          end;

          // 最后一个中间，最后一个中间和结尾的闭区间判断
          if EditPosInPairClose(FEditPos, APair.MiddleToken[I], APair.EndToken) then
          begin
            Inc(Step);
            if Step = FSelectStep then
            begin
              SetStartEndPos(APair.MiddleToken[I], APair.EndToken, False);
              Exit;
            end;
          end;
        end;

        if (APair.MiddleCount > 1) and (I < APair.MiddleCount - 1) then
        begin
          // 某中间且后面有中间，本中间和下一个中间的开区间判断
          if EditPosInPairOpen(FEditPos, APair.MiddleToken[I], APair.MiddleToken[I + 1]) then
          begin
            Inc(Step);
            if Step = FSelectStep then
            begin
              SetStartEndPos(APair.MiddleToken[I], APair.MiddleToken[I + 1], True);
              Exit;
            end;
          end;

          // 某中间且后面有中间，最后一个中间和结尾的闭区间判断
          if EditPosInPairClose(FEditPos, APair.MiddleToken[I], APair.MiddleToken[I + 1]) then
          begin
            Inc(Step);
            if Step = FSelectStep then
            begin
              SetStartEndPos(APair.MiddleToken[I], APair.MiddleToken[I + 1], False);
              Exit;
            end;
          end;
        end;
      end;

      // 如果没找到，则找多结构 Pair 的整个头尾
      if not AreaFound then
      begin
        // 头和结尾的开区间，Step + 1，判断
        if EditPosInPairOpen(FEditPos, APair.StartToken, APair.EndToken) then
        begin
          Inc(Step);
          if Step = FSelectStep then
          begin
            SetStartEndPos(APair.StartToken, APair.EndToken, True);
            Exit;
          end;
        end;

        // 头和结尾的闭区间，Step + 1，判断
        if EditPosInPairClose(FEditPos, APair.StartToken, APair.EndToken) then
        begin
          Inc(Step);
          if Step = FSelectStep then
          begin
            SetStartEndPos(APair.StartToken, APair.EndToken, False);
            Exit;
          end;
        end;
      end;
    end;
  end;

begin
  EditControl := CnOtaGetCurrentEditControl;
  if EditControl = nil then
    Exit;
  try
    EditView := EditControlWrapper.GetEditView(EditControl);
  except
    Exit;
  end;

  if EditView = nil then
    Exit;

  CurIsPas := IsDprOrPas(EditView.Buffer.FileName) or IsInc(EditView.Buffer.FileName);
  CurIsCpp := IsCppSourceModule(EditView.Buffer.FileName);
  if (not CurIsCpp) and (not CurIsPas) then
    Exit;

  // 解析
  PasParser := nil;
  CppParser := nil;
  BlockMatchInfo := nil;

  try
    if CurIsPas then
    begin
      PasParser := TCnGeneralPasStructParser.Create;
  {$IFDEF BDS}
      PasParser.UseTabKey := True;
      PasParser.TabWidth := EditControlWrapper.GetTabWidth;
  {$ENDIF}
    end;

    if CurIsCpp then
    begin
      CppParser := TCnGeneralCppStructParser.Create;
  {$IFDEF BDS}
      CppParser.UseTabKey := True;
      CppParser.TabWidth := EditControlWrapper.GetTabWidth;
  {$ENDIF}
    end;

    Stream := TMemoryStream.Create;
    try
      CnGeneralSaveEditorToStream(EditView.Buffer, Stream);

      // 解析当前显示的源文件
      if CurIsPas then
        CnPasParserParseSource(PasParser, Stream, IsDpr(EditView.Buffer.FileName)
          or IsInc(EditView.Buffer.FileName), False);
      if CurIsCpp then
        CnCppParserParseSource(CppParser, Stream, EditView.CursorPos.Line, EditView.CursorPos.Col);
    finally
      Stream.Free;
    end;

    if CurIsPas then
    begin
      // 解析后再查找当前光标所在的块，不直接使用 CursorPos，因为 Parser 所需偏移可能不同
      CnOtaGetCurrentCharPosFromCursorPosForParser(CharPos);
      PasParser.FindCurrentBlock(CharPos.Line, CharPos.CharIndex);
    end;

    BlockMatchInfo := TCnBlockMatchInfo.Create(EditControl);
    BlockMatchInfo.LineInfo := TCnBlockLineInfo.Create(EditControl);

    // 把有用的 Token 加入 BlockMatchInfo 中
    for I := 0 to PasParser.Count - 1 do
    begin
      if PasParser.Tokens[I].TokenID in csKeyTokens + [tkProcedure, tkFunction, tkOperator, tkSemiColon] then
        BlockMatchInfo.AddToKeyList(PasParser.Tokens[I]);
    end;

    // 转换一下
    for I := 0 to BlockMatchInfo.KeyCount - 1 do
      ConvertGeneralTokenPos(Pointer(EditView), BlockMatchInfo.KeyTokens[I]);

    // 检查配对，生成多个 Pair，注意加入了 Procedure 作为 Pair
    BlockMatchInfo.IsCppSource := CurIsCpp;
    BlockMatchInfo.CheckLineMatch(EditView, False, False, True);

    // BlockMatchInfo 的输出是 LineInfo 内的内容，生成多个 Pair

    // 去掉每个 Pair 尾部不合理的内容比如 else
    for I := 0 to BlockMatchInfo.LineInfo.Count - 1 do
      FixPair(BlockMatchInfo.LineInfo.Pairs[I]);
    BlockMatchInfo.LineInfo.SortPairs;

{$IFDEF DEBUG}
//    for I := 0 to BlockMatchInfo.LineInfo.Count - 1 do
//    begin
//      Pair := BlockMatchInfo.LineInfo.Pairs[I];
//      CnDebugger.LogFmt('Dump Pairs: #%d From %d %d ~ %d %d, ^%d %s ~ %s', [I,
//        Pair.StartToken.EditLine, Pair.StartToken.EditCol, Pair.EndToken.EditLine,
//        Pair.StartToken.EditCol, Pair.Layer, Pair.StartToken.Token, Pair.EndToken.Token]);
//    end;
{$ENDIF}

    FStartPos.Line := -1;
    FEndPos.Line := -1;
    MaxInnerLayer := NO_LAYER; // -2 不存在
    MinOutLayer := MaxInt;

    // 只有在初始按下热键时才记录光标并作为搜索起始光标，自己扩展选择区域造成的光标移动不算
    if (FSelectStep <= 1) or ((FEditPos.Line = -1) and (FEditPos.Col = -1)) then
      FEditPos := EditView.CursorPos;

    // 得到光标所在 Pair 的最深层
    InnerPair := nil;
    InnerIdx := -1;
    for I := 0 to BlockMatchInfo.LineInfo.Count - 1 do
    begin
      // 先找跨光标位置的最内层也就是 Layer 最大的 Pair
      Pair := BlockMatchInfo.LineInfo.Pairs[I];
      if EditPosInPairClose(FEditPos, Pair.StartToken, Pair.EndToken) then
      begin
        if Pair.Layer > MaxInnerLayer then
        begin
          MaxInnerLayer := Pair.Layer;
          InnerPair := Pair;
          InnerIdx := I;
        end;
        if Pair.Layer < MinOutLayer then
          MinOutLayer := Pair.Layer;
      end;
    end;

{$IFDEF DEBUG}
    CnDebugger.LogFmt('CheckModifiedAndReparse Get Layer from %d to %d.', [MinOutLayer, MaxInnerLayer]);
{$ENDIF}

    if (MaxInnerLayer = NO_LAYER) or (MinOutLayer = MaxInt) then
      Exit;

    // 从内往外逐次递增找适合 FLevel 的，但递增有讲究，并非每个 Layer 只递增 1
    Step := 0;

    // TODO: 扩大小括号、中括号选区，看是否在 InnerPair 内，在则递增 Step 并和 FLevel 比较判断

    // 从 InnerPair 的光标所在开区间到光标所在闭区间，如果 InnerPair 是多结构语句则下一个是整个闭区间
    AreaFound := False;
    if InnerPair <> nil then
    begin
{$IFDEF DEBUG}
//      CnDebugger.LogFmt('To Search Current Inner Pair %d %d to %d %d with Level %d',
//        [InnerPair.StartToken.EditLine, InnerPair.StartToken.EditCol,
//        InnerPair.EndToken.EditLine, InnerPair.StartToken.EditCol, InnerPair.Layer]);
{$ENDIF}
      SearchInAPair(InnerPair);

      if not AreaFound then
      begin
{$IFDEF DEBUG}
        CnDebugger.LogMsg('InnerPair Search Complete. To Search Other Pairs');
{$ENDIF}
        PairLevel := InnerPair.Layer;
        while PairLevel >= 0 do
        begin
{$IFDEF DEBUG}
//          CnDebugger.LogMsg('In Loop To Find Another Pair with Level ' + IntToStr(PairLevel));
{$ENDIF}
          for I := InnerIdx downto 0 do
          begin
            // 每退一层 Pair，找开区间，Step + 1，判断，再找闭区间，Step + 1，判断
            // 再判断该 Pair 是否有同级的 procedure/function，有则闭区间 Step + 1，判断
            // 再进外一层重复上述循环。注意起始条件会包括已经搜过的 InnerPair

            Pair := BlockMatchInfo.LineInfo.Pairs[I];
            CursorInPair := False;
{$IFDEF DEBUG}
//            CnDebugger.LogFmt('To Check Pair with Level %d. Is %d %d in From %d %d %s to %d %d %s',
//              [Pair.Layer, FEditPos.Line, FEditPos.Col,
//              Pair.StartToken.EditLine, Pair.StartToken.EditCol, Pair.StartToken.Token,
//              Pair.EndToken.EditLine, Pair.EndToken.EditEndCol, Pair.EndToken.Token]);
{$ENDIF}
            if (Pair <> InnerPair) and EditPosInPairClose(FEditPos, Pair.StartToken, Pair.EndToken) then
            begin
              // 不搜已经搜过的 InnerPair
              CursorInPair := True;
              if Pair.Layer = PairLevel then
              begin
{$IFDEF DEBUG}
//                CnDebugger.LogFmt('Level Match In Pair %d %d to %d %d. To Search in this Pair with Level %d',
//                  [Pair.StartToken.EditLine, Pair.StartToken.EditCol, Pair.EndToken.EditLine, Pair.EndToken.EditCol, Pair.Layer]);
{$ENDIF}
                SearchInAPair(Pair);
              end;
            end;
            if Pair = InnerPair then // 已经搜过的 InnerPair，光标必然在此 Pair 内
              CursorInPair := True;

            // 无论是不是搜过的 InnerPair，只要它是符合级别的 begin/end，且包含光标位置，就要搜其同级的 if 等
            if not AreaFound and CursorInPair and (Pair.Layer = PairLevel) and (Pair.MiddleCount = 0) and
              (Pair.StartToken.TokenID = tkBegin) and (Pair.EndToken.TokenID = tkEnd) then
            begin
{$IFDEF DEBUG}
              CnDebugger.LogMsg('Not Found in This Pair. Check other Pairs with Same Level ' + IntToStr(Pair.Layer));
{$ENDIF}
              // 找有无和 Pair 这对 begin end 同级的 if/then、while/do、procedure/function，中间不能再碰见同级的 begin end
              for J := I - 1 downto 0 do
              begin
                TmpPair := BlockMatchInfo.LineInfo.Pairs[J];
                if TmpPair.Layer = Pair.Layer then
                begin
                  // 如有同级的 begin end 表示后面即使有 if 什么的也不是在一块的
                  if (TmpPair.StartToken.TokenID = tkBegin) and (TmpPair.EndToken.TokenID = tkEnd) then
                    Break;

                  if ((TmpPair.StartToken.TokenID = tkIf) and (TmpPair.EndToken.TokenID = tkThen))
                    or ((TmpPair.StartToken.TokenID = tkWhile) and (TmpPair.EndToken.TokenID = tkDo))
                    or ((TmpPair.StartToken.TokenID = tkFor) and (TmpPair.EndToken.TokenID = tkDo))
                    or ((TmpPair.StartToken.TokenID = tkWith) and (TmpPair.EndToken.TokenID = tkDo)) then
                  begin
{$IFDEF DEBUG}
                    CnDebugger.LogMsg('Get Same Level ' + IntToStr(Pair.Layer) + ' ' + TmpPair.StartToken.Token);
{$ENDIF}
                    Inc(Step);
                    if Step = FSelectStep then
                    begin
                      SetStartEndPos(TmpPair.StartToken, Pair.EndToken, True);
                      Exit;
                    end;
                    Inc(Step);
                    if Step = FSelectStep then
                    begin
                      SetStartEndPos(TmpPair.StartToken, Pair.EndToken, False);
                      Exit;
                    end;
                    Break; // 已经找到了同级 if 等语句，不用再找 function/procedure 了
                  end;

                  // 继续找同级上面相邻的 function/procedure
                  if (TmpPair.StartToken.TokenID in [tkProcedure, tkFunction, tkOperator])
                    and (TmpPair.EndToken.TokenID in [tkProcedure, tkFunction, tkOperator]) then
                  begin
                    Inc(Step);
                    if Step = FSelectStep then
                    begin
                      // 函数过程就闭区间，没有开区间
                      SetStartEndPos(TmpPair.StartToken, Pair.EndToken, False);
                      Exit;
                    end;
                    Break;
                  end;
                end;
              end;
            end;
          end;
          Dec(PairLevel); // 是否在本层？
        end;
      end;
    end;

    if not AreaFound then
    begin
      // 没有所在的层，或啥都没找到，直接全选整个文件
      FStartPos.Line := 1;
      FStartPos.CharIndex := 0;
      FEndPos.Line := EditView.Buffer.GetLinesInBuffer;
      LastS := CnOtaGetLineText(FEndPos.Line, EditView.Buffer);
      FEndPos.CharIndex := Length(LastS);
      Exit;
    end;
  finally
    BlockMatchInfo.LineInfo.Free;
    BlockMatchInfo.LineInfo := nil;
    BlockMatchInfo.Free; // LineInfo 设 nil 后这里的 Clear 才能进行
    PasParser.Free;
    CppParser.Free;
  end;
end;

constructor TCnEditorExtendingSelect.Create(AOwner: TCnCodingToolsetWizard);
begin
  inherited;
  FTimer := TTimer.Create(nil);
  FTimer.Interval := 500;
  FTimer.OnTimer := OnSelectTimer;
  EditControlWrapper.AddEditorChangeNotifier(EditorChanged);
end;

destructor TCnEditorExtendingSelect.Destroy;
begin
  EditControlWrapper.RemoveEditorChangeNotifier(EditorChanged);
  FTimer.Free;
  inherited;
end;

procedure TCnEditorExtendingSelect.EditorChanged(Editor: TCnEditorObject;
  ChangeType: TCnEditorChangeTypes);
begin
  if ChangeType * [ctView, ctModified, ctTopEditorChanged, ctOptionChanged] <> [] then
    FNeedReparse := True;

  if not FSelecting and (ChangeType * [ctBlock] <> []) then
  begin
    FSelectStep := 0;
    FEditPos.Line := -1;
    FEditPos.Col := -1;
  end;
end;

procedure TCnEditorExtendingSelect.Execute;
var
  CurrIndex: Integer;
  EditView: IOTAEditView;
  CurrTokenStr: TCnIdeTokenString;
begin
  EditView := CnOtaGetTopMostEditView;
  if EditView = nil then
    Exit;

  // 理想情况：
  // 如果没有选择区，则选当前标识符并设 Level 1，无标识符的话解析并选最内层开区间，并设 Level 2
  // 如果有选择区，则解析，并根据当前 Level 层数加 1 选择
  // 层级计数顺序：无选择区 0，光标下标识符 1（不一定有），当前块块内开区间 2，
  // 当前块闭区间（也就是整个块，后面有分号就加个分号）3
  // 和当前块同级的所有块（如果还有其他块的话）4，次外块内开区间 5，以此类推

  FSelecting := True;
  try
    if (EditView.Block = nil) or not EditView.Block.IsValid then
    begin
      if CnOtaGeneralGetCurrPosToken(CurrTokenStr, CurrIndex) then
      begin
        if CurrTokenStr <> '' then
        begin
          // 光标下有标识符，选中
          CnOtaSelectCurrentToken;
          Exit;
        end;
      end;
    end;

    Inc(FSelectStep);
{$IFDEF DEBUG}
    CnDebugger.LogFmt('EditorExtendingSelect To Select Step %d.', [FSelectStep]);
{$ENDIF}

    CheckModifiedAndReparse;

    // 选择 FLevel 对应的区
    if (FStartPos.Line >= 0) and (FEndPos.Line >= 0) then
    begin
      CnOtaMoveAndSelectBlock(FStartPos, FEndPos);
{$IFDEF WIN64}
      EditView.Paint;
{$ENDIF}
    end;
  finally
    FTimer.Enabled := False;
    FTimer.Enabled := True; // 半秒钟后重置 FSelecting
  end;
end;

function TCnEditorExtendingSelect.GetCaption: string;
begin
  Result := SCnEditorExtendingSelectMenuCaption;
end;

function TCnEditorExtendingSelect.GetDefShortCut: TShortCut;
begin
  Result := TextToShortCut('Alt+Q');
end;

procedure TCnEditorExtendingSelect.GetToolsetInfo(var Name, Author,
  Email: string);
begin
  Name := SCnEditorExtendingSelectName;
  Author := SCnPack_LiuXiao;
  Email := SCnPack_LiuXiaoEmail;
end;

function TCnEditorExtendingSelect.GetHint: string;
begin
  Result := SCnEditorExtendingSelectMenuHint;
end;

procedure TCnEditorExtendingSelect.OnSelectTimer(Sender: TObject);
begin
  FSelecting := False;
end;

initialization
  RegisterCnCodingToolset(TCnEditorExtendingSelect);

end.
